// src/cyclic_toposort.ts
import { acyclic_toposort } from "./acyclic_toposort";
import { CyclicResult, Edge } from "./types";
import {
	areSetsEqual,
	deepCopyMapSet,
	findNodesWithEmptySet,
	generate_reduced_ins_outs,
	recreateEdgesFromIns,
	removeNodes,
} from "./utils";

/**
 * Recursively identifies minimal sets of edges whose removal breaks all cycles.
 *
 * @param node_ins Map of node -> set of incoming nodes.
 * @param node_outs Map of node -> set of outgoing nodes.
 * @returns Array of sets of cyclic edges (each a minimal solution).
 */
function _cyclic_toposort_recursive(
	node_ins: Map<number, Set<number>>,
	node_outs: Map<number, Set<number>>
): Array<Set<Edge>> {
	// Create copies to modify locally
	const current_node_ins = deepCopyMapSet(node_ins);
	const current_node_outs = deepCopyMapSet(node_outs);

	// Stores lists of potential cyclic edge sets found so far.
	// Starts with an empty set, representing the possibility of no cycles.
	let cyclic_edges_list: Array<Set<Edge>> = [new Set()];

	while (true) {
		// Phase 1: Remove dependencyless nodes (nodes with no incoming edges)
		const dependencyless_nodes = findNodesWithEmptySet(current_node_ins);
		if (dependencyless_nodes.size > 0) {
			removeNodes(current_node_ins, current_node_outs, dependencyless_nodes);
			// If removing nodes empties the graph, we're done with this path
			if (current_node_ins.size === 0) {
				// Check if any nodes with dependencies remain
				// Check if any nodes remain at all in outs map as well
				let actual_nodes_remaining = false;
				for (const _ of current_node_outs.keys()) {
					actual_nodes_remaining = true;
					break;
				}
				if (!actual_nodes_remaining) {
					return cyclic_edges_list; // Base case: graph is acyclic or empty
				}
			}
			continue; // Repeat Phase 1
		}

		// Phase 2: Remove followerless nodes (nodes with no outgoing edges)
		// This is done only if no dependencyless nodes were found in Phase 1
		const followerless_nodes = findNodesWithEmptySet(current_node_outs);
		if (followerless_nodes.size > 0) {
			removeNodes(current_node_ins, current_node_outs, followerless_nodes);
			// After removing followerless, go back to check for dependencyless again
			continue; // Go back to Phase 1
		}

		// Phase 3: Cycle resolution
		// This is reached only if there are no dependencyless and no followerless nodes.
		// The remaining graph must contain one or more cycles.
		else {
			const current_edges = recreateEdgesFromIns(current_node_ins);
			if (current_edges.size === 0) {
				// Should not happen if node_ins wasn't empty, but safety check
				return cyclic_edges_list;
			}

			let min_cyclic_edges_count = Infinity;
			let new_cyclic_edges_list: Array<Set<Edge>> = [];

			// Iterate through potential edge removals generated by the utils function
			const generator = generate_reduced_ins_outs(
				current_edges,
				current_node_ins,
				current_node_outs
			);

			for (const {
				reduced_ins,
				reduced_outs,
				forced_cyclic_edges,
			} of generator) {
				// Pruning optimization: if the edges forced cyclic in this step *alone*
				// exceed the best count found so far, skip this path.
				if (forced_cyclic_edges.size >= min_cyclic_edges_count) {
					// Use >= for strict pruning
					continue;
				}

				// Recursive call with the graph after removing the 'forced_cyclic_edges'
				const recursive_results = _cyclic_toposort_recursive(
					reduced_ins,
					reduced_outs
				);

				// Combine the newly forced edges with results from the recursion
				for (const reduced_cyclic_set of recursive_results) {
					// Create a combined set of cyclic edges for this path
					const combined_cyclic_set = new Set<Edge>();
					// Add edges using a method robust to tuple comparison issues if any
					forced_cyclic_edges.forEach((edge) => combined_cyclic_set.add(edge));
					reduced_cyclic_set.forEach((edge) => combined_cyclic_set.add(edge));

					const total_cyclic_count = combined_cyclic_set.size;

					if (total_cyclic_count < min_cyclic_edges_count) {
						// Found a new best minimum size
						min_cyclic_edges_count = total_cyclic_count;
						// Replace the list with this new best result
						new_cyclic_edges_list = [combined_cyclic_set];
					} else if (total_cyclic_count === min_cyclic_edges_count) {
						// Found another solution with the same minimum size
						// Add it only if it's not effectively already present
						let is_present = false;
						for (const existing_set of new_cyclic_edges_list) {
							if (areSetsEqual(existing_set, combined_cyclic_set)) {
								is_present = true;
								break;
							}
						}
						if (!is_present) {
							new_cyclic_edges_list.push(combined_cyclic_set);
						}
					}
					// If total_cyclic_count > min_cyclic_edges_count, ignore this path.
				}
			}
			// Return the list of minimal cyclic edge sets found during cycle resolution
			return new_cyclic_edges_list;
		}
	}
	// The loop should only exit via returns inside.
}

/**
 * Topologically sorts a graph that may contain cycles.
 * Identifies a minimal set of cyclic edges to ignore to produce a valid topology.
 *
 * @param edges Set of directed edges ([start_node, end_node]).
 * @param start_node Optional node; edges pointing *to* this node are forcibly treated as cyclic.
 * @returns A tuple: [topology, cyclic_edges].
 *          topology: Array of sets of nodes in topological order.
 *          cyclic_edges: Set of edges identified as cyclic.
 * @throws Error if a valid topological sort cannot be found after cycle removal attempts.
 */
export function cyclic_toposort(
	edges: Set<Edge>,
	start_node: number | null = null
): CyclicResult {
	const node_ins = new Map<number, Set<number>>();
	const node_outs = new Map<number, Set<number>>();
	const cyclic_edges_forced = new Set<Edge>();
	const all_nodes = new Set<number>();

	// Initial processing of edges
	for (const edge of edges) {
		const [start, end] = edge;
		all_nodes.add(start);
		all_nodes.add(end);

		if (start === end) {
			continue; // Ignore self-loops for topology, but they don't affect cycles between distinct nodes
		}

		// Initialize maps for nodes if they don't exist
		if (!node_ins.has(end)) node_ins.set(end, new Set());
		if (!node_outs.has(start)) node_outs.set(start, new Set());
		// Ensure nodes without explicit incoming/outgoing edges in the input are tracked
		if (!node_ins.has(start)) node_ins.set(start, new Set());
		if (!node_outs.has(end)) node_outs.set(end, new Set());

		// Check for forced cyclic edges due to start_node
		if (start_node !== null && end === start_node) {
			cyclic_edges_forced.add(edge);
			// Don't add these forced edges to the initial node_ins/node_outs
			// as they are considered 'removed' from the start for cycle detection.
			continue;
		}

		// Add edge to the graph representation
		node_ins.get(end)!.add(start);
		node_outs.get(start)!.add(end);
	}

	// Ensure all nodes mentioned in edges are present in both maps
	for (const node of all_nodes) {
		if (!node_ins.has(node)) node_ins.set(node, new Set());
		if (!node_outs.has(node)) node_outs.set(node, new Set());
	}

	// Handle case where start_node itself might not be in any edge but needs tracking
	// Handle case where start_node itself might not be in any edge but needs tracking
	if (start_node !== null && !all_nodes.has(start_node)) {
		// Inside this block, start_node is guaranteed non-null. Use '!' to assert this.
		if (!node_ins.has(start_node!)) node_ins.set(start_node!, new Set());
		if (!node_outs.has(start_node!)) node_outs.set(start_node!, new Set());
		all_nodes.add(start_node!); // Make sure it's tracked
	}

	// Call the recursive function to find all minimal sets of cyclic edges
	const list_of_cyclic_edge_sets = _cyclic_toposort_recursive(
		node_ins,
		node_outs
	);

	const possible_results: Array<CyclicResult> = [];

	// Iterate through each potential set of cyclic edges found
	for (const cyclic_edge_set of list_of_cyclic_edge_sets) {
		// Combine the recursively found cyclic edges with the initially forced ones
		const combined_cyclic_edges = new Set<Edge>();
		cyclic_edge_set.forEach((edge) => combined_cyclic_edges.add(edge));
		cyclic_edges_forced.forEach((edge) => combined_cyclic_edges.add(edge));

		// Create the graph to be sorted by removing the combined cyclic edges
		const current_edges_for_acyclic_sort = new Set<Edge>();
		for (const edge of edges) {
			let is_cyclic = false;
			for (const cyclic_edge of combined_cyclic_edges) {
				if (edge[0] === cyclic_edge[0] && edge[1] === cyclic_edge[1]) {
					is_cyclic = true;
					break;
				}
			}
			if (!is_cyclic) {
				current_edges_for_acyclic_sort.add(edge);
			}
		}

		try {
			const topology = acyclic_toposort(current_edges_for_acyclic_sort);
			possible_results.push([topology, combined_cyclic_edges]);
		} catch (error) {
			console.error(
				"Acyclic sort failed after removing supposed cyclic edges. This might indicate an issue.",
				{
					error,
					removed_edges: Array.from(combined_cyclic_edges),
					edges_tried: Array.from(current_edges_for_acyclic_sort),
				}
			);
		}
	}

	if (possible_results.length === 0) {
		throw new Error(
			"Could not find a valid topological sort after cycle removal attempts."
		);
	}

	// Heuristic: prefer minimal cyclic edge sets where edges point *to* nodes with high in-degree
	let best_result = possible_results[0];
	let best_score = -Infinity;

	for (const result of possible_results) {
		const cyclic_edges = result[1];
		let score = 0;
		for (const [start, end] of cyclic_edges) {
			const indegree = node_ins.get(end)?.size ?? 0;
			score += indegree;
		}
		if (score > best_score) {
			best_score = score;
			best_result = result;
		}
	}

	return best_result;
}
